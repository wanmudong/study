# 代码的坏味道

[TOC]



> 如果尿布坏了，就换掉它。

知道how不代表知道when。决定何时重构、何时停止和知道重构机制如何运转是一样重要的。

代码需要重构并不代表着代码无法被使用，更多的是代码让阅读者感到厌恶，在本章，作者用”臭味“形容代码的腐朽程度以及需要被重构的急迫。后续也说明了诸多有臭味的迹象。

### 3.1 duplicated code (重复的代码)

在多个地方看见相同的一段代码，不用多想，唯一应该做的就是合并。

需要注意的是，在各种出现重复代码的场景下，我们需要明确对于合并后的方法，应该归属于哪一个class。

### 3.2 long method （过长函数）

 方法过长必然会导致阅读时难以理解。

> 应该积极地分解函数。遵循这样的原则：每当感觉需要一个注释来说明的时候，就需要把说明的东西写进一个独立函数中，并一起用途（而非实现手法）命名。

注释常常是因为代码本身存在着与实际用途的差异。

> 条件式和循环常常也是提炼的信号。

复杂的条件判断容易让人眩晕。将其抽离后，以函数名称，会更加易于理解与使用。

### 3.3 large class （过大类）

> 如果想利用单一class做太多事情，其内就会出现太多instance变量。

在遇到的代码中，变量不多见，但由于类太大而带来的重复代码倒是很容易见到，这就需要我们发挥抽离与合并的技巧了。

### 3.4 long parameter list （过长参数列）

> 太长的参数列难以理解，太多参数会导致前后不一致、不易使用，而且一旦你需要更多数据，就不得不修改它。

除非在明确的场景下使用明确的参数，尽可能使用使用方法时传递对象。用对象隐藏参数。一般个人觉得，超过两个参数时就可以考虑使用对象传参。

### 3.5 divergent change （发散式变化）

> 针对某一外界变化的所有相应修改，都应该只发生在单一class中。

我们常说的单一职责，是一种权利，也是一种义务，一种当外界发生变化时不让其他人感知到的义务。

### 3.6 shotgun surgery （散弹式修改）

> 如果每遇到某种变化，都必须在不同clss中作出修改以响应，那就面临这shotgun surgery。

divergent change是指一个class应对多种变化；shotgun surgery是指一种变化影响了多个class。二者最终的修改模板都是让外界变化与修改类呈现一对一关系。

### 3.7 feature envy（依恋情结）

> 对象技术的全部要点在于：这是一种将数据和加诸其上的操作行为包装在一起的技术。

> 有一种经典气味：函数对于某个class的兴趣高过对于自己所处之class的兴趣。

对于这种类似的情况，其解决的原则在于：将总是一起变化的东西放到一块。

让数据与操作数据的行为一起发送变化，如果有例外，则将例外搬离这个变化中。

### 3.8 data clumps （数据泥团）

> 存在于不同类中，却总是捆绑在一起出现的数据真应该放进属于他们自己的对象。
>
> 有一个方法：当删掉众多数据中的一笔，如果其他数据而因此失去意义，则应该产生一个新对象。

这个本质是多个class中的数据产生了依赖，此时应该认为，既然一起出现，就应该生活在一起。

### 3.9 primitive obsession （基本型别偏执）

> 对象技术的新手往往不愿意在小任务上运用小对象

多多尝试将数据值转换成对象。

### 3.10 switch statements 

> 面向对象的一个明显特征就是：少用switch语句。

我们尝尝通过switch来执行不同的逻辑，更多的去思考，是否可以将其通过多态进行替换。

这取决于使用switch的目的，我们通过都可以通过不同的设计模式来将其替换。

### 3.11 parallel inheritance hierarchies （平行继承体系）

> 其本身是shitgun surgery中的一种特殊情况。当你为一个class新增一个subclass时，也要为另一个class增加一个subclass。

这是业务没有内聚的一个体现。一般的做饭是将两个class进行聚合，避免多处变化。

### 3.12 lazy class （冗赘类）

当一个类失去了原有价值时，及时删除它。

### 3.13 speculative generality（夸夸其谈未来性）

删除当下无用的代码。避免一些所谓未来有用的代码扰乱了当前代码的可阅读性。

### 3.14 temporary field （令人迷惑的暂时值域）

> class中某个instance变量仅为某特定场景而存在，要考虑他应该存在的位置。

在特定情况下，譬如函数传参时没有显示传参，而是通过class的变量传参，这种可以考虑将遍历与函数单独抽离出来，以类似状态机的方式进行使用。

### 3.15 mesage chains（过度耦合的消息链）

> 如果你看到用户向一个对象所求另一个对象，然后向后者索求另一个，然后持续的索求下去，那么这就是message chains

这会导致，一旦某个对象或者变量发生修改，就要相应改变。

可以将这一长串代码抽出为一个方法，进行隔离。

### 3.16 middle man（中间转手人）

> 对象的基本特征之一就是封装，对外部世界隐藏内部细节。
>
> 封装往往伴随着委托（delegation），如果一个类中一半以上的函数再被调用时都通过委托而使用，那么就是过度运用委托了。

这种情况下，class本身的意义就不是很大了，将额外的行为放到调用方或者抽为子类进行使用。

### 3.17 Inappropriate intimacy （狎昵关系）

> 有时你会看到两个class过于亲密，花费太多时间去探究彼此的private成分。我们希望他们严守清规。



### 3.18 Alternative classer with different interfaces（异曲同工的类）

> 两个函数做着同一件事情，却有着不同的签名式。

考虑将之纳入同一体系中。



### 3.19 Incomplete library class（不完美的程序库类）

代码依赖的程序类库存在一定问题时，常常做的是在代码中进行兼容，同时提需求给对应类库，通过下次更新类库版本。

### 3.20 data class （纯稚的数据库）

> 所谓dataclass 是指他们拥有一些值域，以及用于访问值域的函数，除此之外一无长物。

对于贫血对象，多一些功能。

### 3.21 refused bequest (被拒绝的馈赠)

> Subclass 应该继承superclass的函数和数据。但如果他们不想或不需要继承，又该怎么办呢？他们得到了所有礼物，却只从中挑选几样来玩。

不太理解。

### 3.22 comments （过多的注释）

> 当你感觉需要撰写注释，先尝试重构，试着让所有注释都变得多余。