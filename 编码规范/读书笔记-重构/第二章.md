## 重构原则

[TOC]

说在前面：这一章的作用在于，掌握原则，当出现重构方法彼此冲突时，我们能够知道应该选择哪一个。



### 何谓重构

本节从两个角度定义重构，分别是名词形式以及动词形式。

> 重构（名词）：对软件内部结构的一种调整，目的是在不改变「软件之可察行为」前提下，提高其可理解性，降低其修改成本

> 重构（动词）：使用一系列重构准则（手法），在不改变「软件之可察行为」前提下，调整其结构。

我认为，对一件事情的定义是无法对其单方面对其定性，需要在各个角度进行解释后，才能对一件事情得出较为完整的定义。在这里，重构的名词定义，回答了**重构这件事情是做什么**的。重构的动词定义，回答了**重构这件事该如何做**。

> 重构就只是整理代码吗？
>
> 它提供了一种更高效且受控的代码整理技术

这里，我认为提到的是重构对外暴露出的本质，或者说是最终达到的效果：整理既有代码。只是在我们整理的过程中，可以总结得到一套系统的方法论，从而为我们后续的代码整理提效。

> 重构的目的是是软件更容易被理解
>
> 重构之后的软件功能一如以往

这是对重构定义的扩展：整理得到的既有代码应该是什么样的。我们都能理解“整理”是使软件系统的信息熵得以降低的过程。而为了更加可视化的看见这种信息熵的降低，给出了两个可以衡量的点：软件更容易被理解、软件功能不改变。

#### 两顶帽子

绝大部分场景的重构是为了添加新功能，也就使得我们常常有两件事情要一起做：「添加新功能」和「重构」。

二者是交替进行的，需要**我们千万小心，要始终记得自己是在做什么**。



### 为何重构

#### 改进软件设计

代码会逐渐腐朽，为了延缓腐朽或者挣脱腐朽，需要通过重构代码，赋予其新生。

程序需要考虑两件事情：今天可以做什么，明天可以做什么。

我认为，多考虑当下的业务与未来的代码。当下的业务是确定的，未来的代码是可能确定的。以更加扩展的代码，去考虑兼容以后的逻辑。



#### 使软件更容易被理解

增加代码的可读性。这里自私一点，可以理解为，为第二次再来改代码的自己留一条路。

#### 帮你找到bug

这一点体会不深。

#### 助你提高编程速度

良好设计是快速软件开发的根本。好的代码只需要关心如何新增功能，而无需再去小心翼翼的修改“屎山”。





### 何时重构

#### 三次法则

> 事不过三，三则重构

当我们第三次做类似的事情时，应该对代码进行重构，避免第四次做这样的事情。

#### 添加功能时一并重构

添加新功能时，需要我们先去理解老功能，这最好的方式就是以重构的思想去想着如何去做。一是为了理解，二是为了方便新增功能。

#### 修补错误时一并重构

调试过程中可以想着去重构，但出现线上问题紧急修复时，还是需要慎重。

#### 复审代码时一并重构

CR后重构代码，这就要求我们CR的时间要越早越好。



### 重构的难题

一项技术，有好必有坏，福祸总相依，重构会有什么问题呢？

#### 数据库

> 「重构」经常出问题的一个领域就是数据库。

从我的经历来看，或者说团队的影响下，总是会通过仓储层对数据获取的实现进行封装，隔离了业务上对于数据来源的感知。我们可以在仓储层的实现中对数据来源进行替换或者封装，这并不影响上一层级的使用。所以这一节是早已在脑海中的。



#### 修改接口

日常的修改接口存在两个场景：接口升级，兼容更多场景；新增接口，覆盖需求场景。

接口升级这一块值的注意的是：接口本身定义的升级与接口协议的升级。

- 接口定义的变更：这种往往是原有参数。返回值不满足场景，此时需要新增接口，且将原有接口声明为已废弃。
- 接口协议的变更：如nova接口变为dubbo接口，从性质来说，是应用本身的服务以不同的形式暴露给外部，保持内部统一代码即可。

新增接口会有些注意点：

> 不要过早发布接口

现实中，需要先定义接口提供给外部使用，这要求我们要**提前明确需求，将接口定义作为技术方案的核心点之一**。



#### 通过难以重构手法完成的设计改动

> 我会问自己：将某个设计重构为另一个设计的难度有多大？如果看上去简单，我就会选最简单的设计，即使他无法满足潜在的需求。

这里与实现模式中提到的类似，当前的成本总是高于未来的成本，我们的目的是尽可能满足现有需求场景，在满足上一步的前提下，优化设计，满足未来可能的改动。



#### 何时不该重构

> 重写的讯号：现有代码无法正常运行。
>
> 项目临近最后期限，应该避免重构。

前者需要我们直接退单重来，而后者需要我们反思为什么没有提前重构。如果出现后者，需要深刻复盘。



### 重构与设计

> 如果你选择重构，问题的重点就转变了。你任然做预先设计，但是不必一定找出正确的解决方案。此刻的你只需要得到一个足够合理的解决方案就够了。

> 任何一个需求都让我提心吊胆地猜疑：在系统寿命期间，这个需求会导致怎样的变化？由于变更设计的代价非常高昂，所以我希望建造一个足够灵活、足够强固的解决方案，希望它能承受我所能遇见的所有需求变化。问题在于，灵活解决方案的成本难以估计。

着眼当下，前上上一节相通。尽可能用最低成本满足当下需求。



#### 题外话

> 计算机科学是这样一门科学：它相信所有的问题都可以通过多一个间接层来解决
>
> 间接层的价值：允许逻辑共享、分开解释「意图」与「实现」、将变化加以隔离、将条件逻辑加以编码

我们常说的消除重复、隔离变化、条件判断写的太复杂，都是通过抽离代码，新增一个间接层而达到的。**这里还是要多想想如何更好的新增间接层。**



### 重构与性能

权衡被人阅读与被机器阅读的成本。

被人阅读的成本：后来人理清代码与新增逻辑所花费的时间，这是可以被自己所确认的。

被机器阅读的成本：即性能。**我们需要通过工具来判断「软件可察之行为」是否发生了变动：JVM监控、SOA监控，以及最为重要的集成测试。**



