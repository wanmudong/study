## 重构函数

代码的作用时实现程序功能，功能则绝大部分体现在函数上。优化代码，优化功能，其最直接的提现就是重构函数。

重构函数的重点：让函数简洁易懂

### 1、extract method 提炼函数

> 计算机科学是这样一门科学：它相信所有的问题都可以通过多一个间接层来解决

看见一个不明所以的函数时，首先要知道他做了什么，怎么做的。之后将之拆解为多段逻辑，提炼为多个函数。

**关注点：函数命名、有涉及局部变量时的处理方式。**

#### 被提炼的函数未涉及了原函数的局部变量

小部分场景下，代码块中没有局部变量：我们其实只需要将这一大段代码提炼出来，给予他一个合适的名称。当然，**函数的名称很重要。需要体现出它做了什么，而不是体现出它怎么做的。**



#### 被提炼的函数涉及了原函数的局部变量

当代码块存在局部变量时：



- 如果被提取出的代码只是读取了变量的值，那么我们只用将遍历作为参数传递给目标函数。
- 如果被提取的代码对局部变量进行了赋值，情况就变得微妙了起来。
  - 简单的场景中：变量只在被提炼代码区域中使用，则将变量定义一起提炼即可。
  - 其他场景中：变量在被提炼代码区域中使用后再被使用，需要让目标函数返回该变量的值。



### 2、inline method 将函数内联

> 间接层太多影响代码的阅读

当函数本身做的事情与其名称一样清楚易懂时，我们可以摒弃一次函数调用，直接在函数调用点插入函数本体。

还有一种场景：原有函数组织很不合理时，可以先将他们都inline到一个大型函数中，再对大型函数进行重构。此时inline 是真正重构的一个前置操作。



### 3、inline temp 将临时变量内联

> 将所有对该变量的引用动作，替换为对他复制的那个表达式自身

使用场景：

- 作为【以查询替代临时变量】的部分操作
- 临时变量被赋值成了某个函数调用的返回值

备注：试着将临时变量声明为final，这样可以检查该临时变量是否还被其他场景赋值了。



### 4、 replace temp with query 以查询替代临时变量

> 通过临时变量保存某一表达式的运算结果时，可以将表达式提取到一个独立函数，再将这个临时变量的所有引用点替换为对新函数的调用。

临时变量存在的问题：可能在多个函数中都使用相同的表达式生成了相同的临时变量，用于参与计算。将之用query替代，可以方便复用。减少代码量。



### 5、introduce explain variable 引入解释性变量

> 有一个复杂表达式，将表达式结果放进一个临时变量，以变量名称来解释表达式用途。

通常用于将条件表达式转为一个boolean 临时变量。

但对于引入解释性变量，其实也可以使用提炼函数的方法来替换。

我理解，提炼函数与引入解释性变量并不冲突。引入解释性变量可以作为提炼函数的前置操作。先将多个表达式用解释性变量表达，后面再将交叉使用解释性变量的条件判断提炼为函数。



### 6、split temporary variable 剖解临时变量（确保临时变量只被赋值一次）

> 除了循环变量以及集用临时变量外，其他场景下的临时变量只被赋值一次。每次赋值，创造一个独立的、对应的临时变量。



### 7、remove assignment to parameters 移除对参数的赋值动作

> 当对参数进行赋值时，用临时变量取代该参数的位置。

切记不要修改参数，如果在使用的时候将参数赋值了，那么就用一个临时变量代为被赋值。

java的参数传递方式是：pass by value。对于java，我们可以修改对象的内部状态，但对象重新赋值没有意义。所以函数中对参数的赋值操作很具有迷惑性，让人误以为参数被修改了，调用函数时的变量也被修改了。



### 8、replace method with method object 以函数对象取代函数

> 将大型函数放进一个单独对象中，如此一来局部变量就变成了对象内的值域，然后你可以在同一个对象中将这个大型函数分解为数个小型函数。

场景：函数过于复杂，局部变量过得，导致 无法【提炼函数】。



### 9、substitute algorith 替换你的算法

> 将函数本体替换为另一个算法

变更了计算方式