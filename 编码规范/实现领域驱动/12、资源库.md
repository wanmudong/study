> 资源库是一个安全的存储，它能够为我们的聚合保证在存入与取出后的一致性。

注意：资源库是面向聚合的，对于单个实体，并没有资源库使用的场景。因为此时单个实体并没有一致性保证的必要性。

资源库分为两类：面向集合与面向持久化。二者的差距在于：**底层持久化机制是否跟踪聚合的变化**。

### 面向集合资源库

> 一个资源库应该模拟一个Set集合。无论采用什么类型的持久化机制，我们都不应该允许多次添加同一个聚合实例。另外，当从资源库中取到一个对象并对其进行修改时，我们并不需要”重新保存该对象到资源库中“。

面向集合资源库的方式解释了DDD的基本思想，我们只需对对象进行操作，而无需关注对象的存储。

从实现的角度来看，我们肯定要去保存对象的，否则一断电，对象就从世界上消失了（当然也有分布式的相关问题）。为此，我们要去**跟踪**对象，确保对象的变更能够被资源库感知且被及时存储。这就引申出了两种方案：

- 隐式读时复制：在从资源库中读取一个对象时，持久化机制隐式的对该对象进行复制，提交时，再将复制对象与客户端中的对象进行比较，将差异进行存储。
- 隐式写时复制：持久化机制通过委派来管理所有被加载的持久化对象，当通过委派对象来变更对象时，他将复制一份对象的备份，然后将对应变更的内容标记为dirty，在事务提交时，检查所有肮脏对象并将修改更新进行存储。

要是底层的数据库不支持隐式跟踪怎么办？要么我们自己开发一套框架，在现有基础上搭建一套支持隐式跟踪的适配；要么可以考虑显式追踪，在资源库中显示声明跟踪。而这些前提就是吗没有一个**显式的”存储行为“。**

### 面向持久化资源库

> 在向数据存储中添加新建对象或者修改既有对象时，我们都必须显示地调用put方法，该方法将以新的值替换原先关联在某个键上的原值。这种类型的数据存储可以简化对聚合的读写，因此这种数据存储也被称为存储聚合（Aggregate Store）或者面向聚合数据库（Aggregate-Oriented Datebase）。

简单理解，向mybatis这种非ORM框架，所能实现的就是面向持久化资源库。但我们也可以自己开发一套框架，在现有基础上搭建一套支持隐式跟踪的适配，简化对象比对的实现。但只是简化功能实现，其本质依旧是面向持久化资源库，而不是面向集合资源库，因为此时依旧显示调用了save，即显示声明了存储行为。



### 额外的行为

上面两种的划分，更多的是区分持久化时行为的差异性。对于一些查询，我们也会有一些约束或者说放宽。

1. 通过资源库或者聚合中的部分实体，前提是在聚合根中有该实体集合的导航。
2. 当查询的聚合仅用于显示于界面上，可以将查询结果放在值对象中返回，可以理解为给聚合转换为一个具体的VO，而此时可以由应用层直达资源库。
3. 在聚合边界真确的前提下，如果遇到了复杂的业务查询，同时存在性能问题时（如批量操作中的查询），需要考虑使用CQRS。



### 事务

事务不应当由领域关系，而应当由应用层负责。此时的事务是一个具体场景的事务。



### 资源库与数据访问对象DAO

在设计资源库时，应该采用面向集合的方式而不是面向数据访问的方式。这有助于将自己的领域当做模型来看待而不是CRUD操作。



### 测试资源库

在内存中构建数据库是一个难题，尽管有H2这样的内存数据库实现方式，但常常受限于环境的影响而无法成功启动，因为存在模块间的依赖与中间件底层的依赖。尤其像shop-center这一类有历史债的，向shop-ability-console就能够启动正常。

这里提出来一个很有意思的方案，如果我们不考虑底层的实现，而是关注资源库这一层逻辑的正确性，可以采用Map的形式模拟一个内存数据库，以单侧的形式确保资源库这一层逻辑是正确的。