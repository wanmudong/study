### 方法

将程序划分为方法需要考虑的因素：大小、意图、方法的命名。

#### 组合方法

组合方法本身只是对方法的集成，被其调用的方法应大致属于相同的抽象层次。

注意：组合方法应该根据师师而非推测。先让代码正常工作，再决定怎么安排它的结构。

我的理解是，先让代码正确的跑起来，再去重构它。

#### 揭示意图的名称

应该从潜在调用者的想法触发，根据调用者使用该方法的意图来为方法命名。

调用者为什么调用这个方法而不是其他方法？这就是方法名需要回答的问题。调用方法是在讲述一个故事，好的方法命名会让故事讲的更加流畅。

我的理解：明确方法被调用的业务场景，场景明确了，调用者的想法就被固定了。

#### 方法可见性

方法可见性有两大约束条件，既要向外部用户暴露功能，又要保持未来的灵活性。

我的理解：我们大部分场景下，都会去使用private，这是开发的性质决定的。其他的有两种特殊：接口方法为public，抽象类中面向子类的通用方法未protect。

#### 方法对象

将方法从原有逻辑中抽出，作为一个类中的方法，并在原有逻辑中引用类的实例中对应的方法。

注意：一般只有重构中遇到一大坨代码时才会用到。

#### 覆盖方法

对象编程有很多手段来表达相似计算之间的差异，这是对象编程的亮点，覆盖方法是表达变体的一种清晰的方式。

超类、子类逻辑实现的差异其实就是覆盖方法。

#### 重载方法

用不同的参数类型声明同一个方法，其表达的含义是这个方法的参数有多种格式。

多个重载方法的目的应该一致，不一致的地方应该仅限于参数类型。如果重载方法的返回类型不同，会让代码难以理解。最好为新的意图找一个新的名字，不同的计算应该有不同的名称。

我理解：如果方法名相同，返回值类型相同但返回的实例对象存在差异是可以接收的。譬如返回组织的领域方法中get即可以只传orgId，也可以传orgId与orgStructureType。

#### 方法返回类型

方法返回类型可以识别出它是间接影响的过程还是返回特定对象的函数。

我理解：返回值类型不用想太多，正常返回即可。

#### 方法注释

归根结底，沟通是所有实现模式的首要价值。如果方法注释是最合适的沟通媒介，那就写一个好注释吧。

我理解：遇到注释，先思考代码业务逻辑，在思考如何将注释以重构的方式去除。对于写一段新逻辑也是如此，可以先注释后写代码，最好再以重构的形式除去注释。

#### 助手方法

助手方法是组合方法的衍生物，是将大方法分割成小方法中的小方法本体。

如果方法的逻辑变更不清晰，应该去除助手方法。把所有的助手方法展开到代码中，换个角度去观察方法的逻辑，重新提取出有意义的方法。

我理解：助手方法就是我们最常被提取出的方法的一个称呼。

#### 调试输出方法

如果需要提供便于程序员使用的对象表示，则重载toString方法，其他用途的字符串请表示在其他方法或者单独的类中。

#### 转换

转换模式有哪些的？转换方法、转换构造器。

#### 转换方法

需要表达类型相近的对象之间的转换，而且转换的数量优先，那么应该将转换方法放在源对象内部。

#### 转换构造器

我们常用的静态方法用于转换对象。

#### 创建

如何创建一个对象？这个取决于被创建的对象本身的含义。创建的方式：构造器、工厂方法、内部工厂。

#### 完整的构造器

通过提供无参的构造器和一系列setting方法来创建对象，可以很好的满足灵活性的要求。但无法表达出对象必须有哪些参数组合才能正常运作。

#### 工厂方法

如果要完成的工作比单纯创建对象更复杂，比如还要在缓存中记录对象，或者在运行时觉得创建哪一个子类对象，工厂方法就很合适。

#### 内部工厂

如果要在内部创建一个辅助对象，但创建过程很复杂，或者希望让子类能够改变创建逻辑？可以在内部设立一个方法用于创建并返回新对象。

内部工厂同时也是对子类的邀请，请子类根据需要进行微调。

我理解工厂本身归属于超类，其定下来创建有哪些步骤，而子类内部的工厂需要实现对应的步骤，做到每个子类的创建步骤是不相同的。

#### 容器访问器方法

如果对象包含了一个容器，应该尽量避免让外部感知到这个容器，而是通过提供一下业务上的接口，如：一个对象内部有一个list，可以对外暴露对list的add、remove方法，避免外部通过getting方法获取list后直接操作list本身。

#### 布尔值setting方法

将布尔值的setting方法以更有业务语义方法名取代，如disable、invalid、enable、valid等方法。

#### 查询方法

有时候对象需要根据另一个对象的状态来决定。

我理解：此时应该考虑将两个对象进行融合，因为对象不应该依赖其他对象。

#### 相等性判断方法

注意重写equals方法与hashcode。

我理解：我们现在通过使用Data注解，但注意对于子类对象，是否要依赖超类的字段判断是否相等。

#### getting方法、setting方法

关注点在于：应不应该这么写方法，这么写方法能够满足什么需求，这个需求能不能用一个更有业务语义的方法名取代。

#### 安全副本

要是有两个对象都以为自己可以独占的访问第三个对象，使用getting或者setting方法就会出现别名问题。

别名问题：指内存中的一块数据可以通过多个符号名称访问。

为了避免别名问题，可以在返回或者存储一个对象之前对它进行复制，一次避免一些错误。

我理解：理论上别名问题是第三方对象暴露的方法无法满足两个外部对象的调用而产生的的，所以要具体问题具体解决。