## 基于规则的优化

#### 1. 条件化简

- 移除不必要的括号
- 常量传递
- 等值传递
- 移除无用的条件
- 表达式计算
- having子句与where子句的合并
- 常量表检测：（表中记录《=1；使用等值查询走索引）



#### 2. 外连接消除

对于内连接，驱动表与被驱动表可以相互替换，从而可以通过优化连接顺序来降低查询成本。

外连接中，当where子句中包含被驱动中的列不为NULL时，可以转换为内连接，从而可以通过优化连接顺序降低成本。



#### 3. 子查询优化

按照子查询的返回结果集，可以分为：标量子查询、行子查询、列子查询、表子查询。

按照与外层查询非关系来，可以分为：不相关子查询、相关子查询。



#### 子查询在MySQL中的执行方式

##### 标量子查询、行子查询

对于不相关的标量子查询、行子查询的执行方式：先执行子查询，后执行外部查询。

对于相关的标量子查询、行子查询的执行方式：先外层、再内层，循环执行。

##### in子查询优化

###### 物化表

物化表：将自子查询结果物化为一张表，数量较少时，只存在于内存中，类似临时表；表中记录较多时，会使用基于磁盘的存储引擎保存结果集中的记录。

物化表转连接：此时有了表，in子查询就相当于内连接，就可以以内连接优化的方式对子查询进行优化，且物化表有唯一键，可以避免重复。

###### 半连接

将子查询转换为semi-join：即半连接，在内存中直接将in字查询转换为连接查询，只不过这里的连接查询对于多条相同的数据，只会查询出一条记录。

半连接实现的方式：

- table pull out 子查询中的表上拉：子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表`上拉`到外层查询的`FROM`子句中
- duplicateWeedout execution strategy （重复值消除）：通过临时表，消除重复的数据。
- LooseScan execution strategy （松散扫描）：扫描索引，但只取值相同的记录的第一条去做匹配操作。
- Semi-join Materialization execution strategy：物化表转连接的方式。
- FirstMatch execution strategy （首次匹配）：取一条外层查询的记录，进入子查询中查找符合匹配条件的记录，找到一条后将结果放入结果集。重复这个步骤。

适用半连接的条件：in查询，in查询条件与其他查询条件通过and连接、子查询为单一的查询。

不适用半连接的情况：or、not in、分组查询、子查询有union。

优化不能转为半查询的in子查询：尝试物化后查询；将in子查询转换为exists子查询（为了走索引）。这两种都是mysql内部的优化，我们无需关心。

##### ANY、ALL子查询优化

通过max、min进行转换



##### exists子查询优化

如果`[NOT] EXISTS`子查询是不相关子查询，可以先执行子查询，得出该`[NOT] EXISTS`子查询的结果是`TRUE`还是`FALSE`，并重写原先的查询语句。



##### 对于派生表的优化

子查询放在外层查询的`FROM`子句后，那么这个子查询的结果相当于一个`派生表`。

Mysql两种优化策略：

- 物化派生表：对于派生表，会使用延迟物化，即用到时才物化。
- 将派生表与外层表合并：将查询重写为没有派生表的形式。无法合并的情况：分组查询、聚集函数、limit、union、内部还有子查询。